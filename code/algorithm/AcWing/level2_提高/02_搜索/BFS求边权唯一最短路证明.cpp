给定一个边权唯一的图, 为什么 BFS 可以求最短路
    当遍历到一个点时, 那么这个点就是最短距离
    1) 每次宽搜都会用上队列
       队列的两个性质
         a.两段性: 队列中存的所有点里面到起点的距离, 他们之间的差值最多是 1
            队列:|_x_x_x__|_x+1_x+1_| 前面一段是 x 后面一段是 x+1, 但是后面一段不一定存在
         b.单调性: 一定是单调递增, 前面一段是 x, 后面一段是 x+1

            数学归纳法证明: 
                1) 初始状态:队列中只有一个点, 这个点到起点的距离是 0, 所以初始状态满足
                2) 假设当前状态满足:然后从队头弹出一个点 x, 用 x 去扩展可以扩展到的点并将他们加入对尾,
                   x 到那些点的距离一定是 1, 当然也可能已经被别的点扩展过了,假设这个出队列的节点 x 扩展出 3 个 x+1
                   x|_x_x_x_|_x+1_x+1|_x+1_x+1_x+1
                 ↙  h               t            ↘    
            弹出的x                 (old)         new tail 刚加入队列的三个点

            当 x 全部弹出时, 下一批 x 就成为了 x+1.
                   可以发现这 3 个点依旧是 x+1, 单调性依然保持在前半段是 x, 后半段是 x+1

    所以我们就证明出了队列的 两段性:里面最多有两种值, 队列的单调性: 这些值单调递增
    因为两段性和单调性, 所以我们每次取队头元素的时候相当于取出队列中的最小值
    所以如果所有边权相同的话, BFS 就相当于堆优化的 djikstra, 因为 djikstra 是正确的, 所以 BFS 也是正确的

    堆优化的 djikstra:从优先级队列弹出最小的再用当前最小更新周围点, 出现更小就加入, 
                     但是 djikstra 出队的一定是最小值, 入队的不一定是堆中最小值

    不使用 djikstra 的证明:
    BFS中, 从入队开始就是最小值, 所有点只会入队一次, 也就是说一旦入队值就不会被改变, 这就是单调递增
    入队的时候是最小值, 出队时必然是队列中最小值(主要边权为 1, 出队入队不影响)

            数学归纳法 + 反证法: 归纳假设所有已经出队的值最小值已经确定了, 不会被改变, 
                                初始:一个元素都没有出队列, 所以这是成立的
                                假设:当前已经出队列的元素所有的最小值都已经确定了
                                反证法: 假设出队的 x 不是最小值, 那么 x 后面的那个 x 更新的值会把通往 x 的路径给更新了
                                       且更新后 x 的距离严格变小, 由于再 x 前面的最小值已经确定了, 他们能更新的边
                                       已经更新完了, 也就是说不存在后面的点更新回前面已经出队列的点的可能性, 这就矛盾了
                                
                                所有矛盾点归纳: 因为整个队列是单调递增, 且边权为 1, 所以当前 x 的距离求求出后, 
                                              一定是大于前面 x 求出的距离, 所以不存在后面 x 更新前面 x 的可能
                                              由于 BFS 每个点只能入队一次, 所以一个点在入队开始最小值就已经确定了  
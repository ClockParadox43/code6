// 上节课错误:
// 恰好选择 >= j, >= k 个物品
// f[0,0,0] = 0             -> 当一个物品都不选的时候, 两个物品整个是 0
// f[0,j,k] = 正无穷        -> 不合法       
// 恰好和至少的状态转移方程和初始化方式完全一样
//
//
//
// 花费1:氧气, 花费2:氮气
// 气缸属性:重量, 气体容量
// 目标 : 满足氧气氮气情况下求, 求最小重量
// 选或不选 : 01背包问题
//
// 和二维费用背包问题区别: 
//      - 背包问题: 不能超过某个上限(满足当前体积就能选择)
//      -   该问题: 至少达到某个上限
//
// 
// 氧 >= n, 氮 >= n 
// 
//                       集合: 所有从前 i 个物品中选, 且氧气含量至少是j, 
//                      /      氮气含量至少是 k 的所有选法
//     状态表示 f[i,j,k] 
//   /                  \
// DP                    属性: Min
//   \
//     状态计算 f[i,j,k]
//           ________________________
//          |不含物品i   | 包含物品i |
//          |的所有选法  |  的所有选法|
//          |____________|___________|
//               (1)         (2)
// 
//  1) 从 1~i-1 中选, 氧气含量 >= j, 氮气含量 >= k 的所有选法
//     f[i-1, j, k]
//
//  2) 从 1~i 中选, 氧气含量 + i >= j, 氮气含量 + i >= k 的所有选法
//     p1: * * * ... * i
//     p2: * ... * * * i
//         ......
//     pn: * ..... * * i  
//
// 由于每个方案都包含物品 i, 所以可以把 i 先都去掉
// 先求左边最小值, 再加上物品 i 的重量就是整个最小值
// f[i-1, j-v1, k-v2] + wi
// 
// 两种状态表示不一样的地方:
// 上节课: 在求的时候 j >= v1, k >= v2
//         如果是 j < v1, k < v2
//         上节课的表示中, 体积恰好是负数的最小值 
//         但是体积恰好是负数是不存在的, 所以在枚举的时候只能枚举 >= 的情况
//
// 参考博客: https://www.acwing.com/solution/content/7438/
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1010, M = 22, K = 80;

int V1, V2, n;              // 氧和氮各自需要的量 / n 件物品
int v1[N], v2[N], w[N];     // n 个气缸的 氧, 氮, 重量
int f[N][M][K];

int main()
{
    cin >> V1 >> V2 >> n;

    for (int i = 1; i <= n; ++i) scanf("%d%d%d", &v1[i], &v2[i], &w[i]);

    memset(f, 0x3f, sizeof f);
    f[0][0][0] = 0;

    for (int i = 1; i <= n; ++i)
        for (int j = 0; j <= V1; ++j)                 // 至少需要体积为 j, k 的时候
            for (int k = 0; k <= V2; ++k)
            {
                f[i][j][k] = f[i - 1][j][k];
                f[i][j][k] = min(f[i][j][k], f[i - 1][max(0, j - v1[i])][max(0, k - v2[i])] + w[i]);
            }

    cout << f[n][V1][V2] << endl;

    return 0;
}
// 上节课错误:
// 恰好选择 >= j, >= k 个物品
// 会存在负数的情况, 体积"恰好"是负数是不存在的
// 但是当状态变成体积"至少"是的时候, 就算是负数, 但是那个状态也是存在的 
// 只不够那个状态是0而已
// 恰好和至少的状态转移方程和初始化方式完全一样
//
//
//
// 花费1:氧气, 花费2:氮气
// 气缸属性:重量, 气体容量
// 目标 : 满足氧气氮气情况下求, 求最小重量
// 选或不选 : 01背包问题
//
// 和二维费用背包问题区别: 
//      - 背包问题: 不能超过某个上限(满足当前体积就能选择)
//      -   该问题: 至少达到某个上限
//
// 
// 氧 >= n, 氮 >= n 
// 
//                       集合: 所有从前 i 个物品中选, 且氧气含量至少是j, 
//                      /      氮气含量至少是 k 的所有选法
//     状态表示 f[i,j,k] 
//   /                  \
// DP                    属性: Min
//   \
//     状态计算 f[i,j,k]
//           ________________________
//          |不含物品i   | 包含物品i |
//          |的所有选法  |  的所有选法|
//          |____________|___________|
//               (1)         (2)
// 
//  1) 从 1~i-1 中选, 氧气含量 >= j, 氮气含量 >= k 的所有选法
//     f[i-1, j, k]
//
//  2) 从 1~i 中选, 氧气含量 + i >= j, 氮气含量 + i >= k 的所有选法
//     p1: * * * ... * i
//     p2: * ... * * * i
//         ......
//     pn: * ..... * * i  
//
// 由于每个方案都包含物品 i, 所以可以把 i 先都去掉
// 先求左边最小值, 再加上物品 i 的重量就是整个最小值
// f[i-1, j-v1, k-v2] + wi
// 
// 两种状态表示不一样的地方:
// 上节课: 在求的时候 j >= v1, k >= v2
//         如果是 j < v1, k < v2
//         上节课的表示中, 体积恰好是负数的最小值 
//         但是体积恰好是负数是不存在的, 所以在枚举的时候只能枚举 >= 的情况
// 至少:包含了v>j的情况
// f[0,i]=0:代表一件物品都不选的情况下体积是i的最大价值
//          i不管取多少,i都是被包含在f[0,i]中的, 因此每个f[0,i]都至少包含一个方案
//          最大值就是0
// f[0,i]=正/负无穷:如果是"恰好"为i的话,一件物品都不选但是体积为i,是不合法的
//                  初始化根据求max/min来定
// 参考博客: https://www.acwing.com/solution/content/7438/
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1010, M = 22, K = 80;

int V1, V2, n;              // 氧和氮各自需要的量 / n 件物品
int v1[N], v2[N], w[N];     // n 个气缸的 氧, 氮, 重量
int f[N][M][K];

int main()
{
    cin >> V1 >> V2 >> n;

    for (int i = 1; i <= n; ++i) scanf("%d%d%d", &v1[i], &v2[i], &w[i]);

    // 初始化成正无穷的目的其实是在更新的时候不使用他的值
    memset(f, 0x3f, sizeof f);
    f[0][0][0] = 0;

    for (int i = 1; i <= n; ++i)
        for (int j = 0; j <= V1; ++j)                 // 至少需要体积为 j, k 的时候
            for (int k = 0; k <= V2; ++k)
            {
                f[i][j][k] = f[i - 1][j][k];
                // 这里由于状态表示是至少是j, 所以是存在该状态的, 但是由于负数会越界
                // 所以这里初始化成0
                // 负数和0是等价的, 所以初始化成0对应的总重量也是0, 因为每个气缸的体积都不是0
                // 当我们初始化成0的时候一定意味着我们一个气缸也没有选
                f[i][j][k] = min(f[i][j][k], f[i - 1][max(0, j - v1[i])][max(0, k - v2[i])] + w[i]);
            }

    cout << f[n][V1][V2] << endl;

    return 0;
}
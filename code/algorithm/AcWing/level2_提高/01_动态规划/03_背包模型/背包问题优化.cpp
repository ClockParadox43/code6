01背包: 因为依赖的是上一行, 所以要在更新前转移, 也就是逆序优化

完全背包(每件物品有无限件): 因为依赖的是当前行, 所以顺序着优化
    f[i][j] = max(f[i-1][j], f[i-1][j-w]+v, f[i-1][j-2w]+2v, f[i-1][j-3w]+3v)
    f[i][j-v] = max(         f[i-1][j-w],   f[i-1][j-2w]+v,  f[i-1][j-3w]+2w)

多重背包(每件物品数量有限): 因为数量有限, 也就是会出现物品选完了, 但是背包没有满的情况, 
                           所以转移方程展开对比, 选择当前物品的转移方程 -> 后会有多出的项
    f[i,j] = max(f[i-1,j], f[i-1,j-w]+v, f[i-1,j-2w]+2v, f[i-1,j-3w]+3v ,..., f[i-1,j-sw]+sv)
  f[i,j-v] = max(          f[i-1,j-w],   f[i-1,j-2w]+v,  f[i-1,j-3w]+2v ,... f[i-1,j-sw]+(s-1)w, f[i-1,j-(s+1)w]+sv)
  
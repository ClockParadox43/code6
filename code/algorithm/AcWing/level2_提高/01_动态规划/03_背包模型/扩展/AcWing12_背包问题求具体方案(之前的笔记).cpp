// 01背包问题求具体方案:
//      f[i,j] = max(f[i-1,j], f[i-1, j-v[i]] + w[i]) 每次在两项里面求最大
// 推到 f[n, m]
//
// 动态规划问题求方案其实对应最短路问题      
//
//  f[n-1,m]  
//           \              -> 不选择第 n 个物品的话过来的点, 该边权重为 0
//            f[n,m] 
//           / w[n]         -> 选择第 n 个物品的话过来的点, 该边是有权重的
//  f[n-1,m-v[n]]
// 
// 也就是说每个状态转移方程都可以对应图论中最短路问题 
// (到底是那种问题对应状态表示中的属性, 如果是 max, 那就是求最长路问题)
// 求 DP 问题的具体方案的话, 其实就是求哪条路径走到最终的 f[n,m]
// 
// 如何求所有方案:
//      - 倒着求, 每次求当前点是从哪个点转移过来的
// 
//      如何判断是从哪个点过来的
//          - 上面过来的:f[n-1,m] == f[n,m]
//          - 下面过来的:f[n-1,m-v[i]] + w[n] == f[n,m]
//          判断 f[n,m] 和那条路径上的值相等        
//          如果相等, 就代表第 n 个物品可以选也可以不选, 都可以得到最大价值
//
// 很经典的思路, 因为正序太难求了, 相当于报搜, 所以求上一步简单做个判断就行了
//
//
// 求具体方案时:
//      1) 不能用状态压缩的方式, 必须把两个状态写出来
//      2) 求每个物品是否被选的时候其实就是返推当前状态是从哪个状态过来的
//
// 字典序更小:出题人比较懒, 让返回的答案都是形同的
//            方便判断答案是否正确, 只需要判断两个字符串相等即可    
//            否则需要写程序判断
// 
// 如何解决字典序最小这样的限制:
//      - 90% 情况下, 都可以用贪心得到字典序最小的方案
//      什么情况下字典序最小:
//              1) 只能选 
//              2) 只能不选 
//              3) 可选可不选(一定要选, 选上的字典序一定是最小的, 不选的话不如刚才选法更小)
//      求完后只能从 n 往前推, 得到字典序最小方案只能从前往后推 
//      为了能够从前往后推, 在求 01背包时从后往前推(将循环顺序变成从后往前)
//
// 替代方式:求解 DP 的过程中记录每一步的选择是什么
 
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n, m;
int v[N], w[N];
int f[N][N];

int main()
{
    scanf("%d%d", &n, &m);
    
    for (int i = 1; i <= n; ++ i ) scanf("%d%d", &v[i], &w[i]);
    
    // 0 __|__|__|__ 
    // 1 __|__|__|__  
    // 2 __|__|__|__
    // 3   |  |  |
    // 倒着求一遍背包
    for (int i = n; i >= 1; -- i )
        for (int j = 0; j <= m; ++ j )
        {
            f[i][j] = f[i + 1][j];
            if (j >= v[i]) f[i][j] = max(f[i][j], f[i + 1][j - v[i]] + w[i]);
        }
        
    // f[1][m] 是最大值
    int j = m;
    for (int i = 1; i <= n; ++ i )
        if (j >= v[i] && f[i][j] == f[i + 1][j - v[i]] + w[i])      // 只要可以选那就必选
        {
            cout << i << ' ' ;
            j -= v[i];    
        }
        // 否则必不选
    return 0;
}
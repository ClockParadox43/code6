```c++
01背包: 因为依赖的是上一行, 所以要在更新前转移, 也就是逆序优化

完全背包(每件物品有无限件): 因为依赖的是当前行, 所以顺序着优化 (求的是前缀的最大值)
    f[i][j] = max(f[i-1][j], f[i-1][j-w]+v, f[i-1][j-2w]+2v, f[i-1][j-3w]+3v)
    f[i][j-v] = max(         f[i-1][j-w],   f[i-1][j-2w]+v,  f[i-1][j-3w]+2w) 

多重背包(每件物品数量有限): 因为数量有限, 也就是会出现物品选完了, 但是背包没有满的情况, (求的是滑动窗口内的最大值)
                           所以转移方程展开对比, 选择当前物品的转移方程后会有多出的项.
                           为什么要多减一个 w ? 
                              - 因为公式本身是可以一直推的, k 是无限的, 但背包体积有限, 但 j 必须大于等于 kv,
                                所以完全背包的两个公式会因为 j 的原因停在同一个 k 上
                                而多重背包问题物品数量 k 有限, k 会卡住公式项数

    f[i,j] = max(f[i-1,j], f[i-1,j-w]+v, f[i-1,j-2w]+2v, f[i-1,j-3w]+3v ,..., f[i-1,j-sw]+sv)
  f[i,j-v] = max(          f[i-1,j-w],   f[i-1,j-2w]+v,  f[i-1,j-3w]+2v ,..., f[i-1,j-sw]+(s-1)w, f[i-1,j-(s+1)w]+sv)
                                                                                            \
                           多重背包问题的优化相当于每次求的是一个滑动窗口内的最大值          这里的 's' 和完全背包的 's' 不一样
                      

    j-v, j-2v,...,j-kv 都有一个相同的特点, 他们对 v 同余, 所以可以把余数先设出来
    f[j]是所有是所有同余与 v 的值转移过来的, 比如现在有一个物品 v 是 3, 
    那么 f[0], f[1], f[2] 是三个不同的同余类.
    通俗来说: j 一直减 v, 减到最后减不开 v 了, 剩下的数就是 r

                            ——|————|————|————|————|————|————|————|————|——               完全背包的 's' 是指体积不超过 'j' 的情况下的最大的一个 's'
                              r   r+v  r+2v r+3v r+4v r+5v ...  j+2v  j+v               多重背包的 's' 代表题目给定的 's', 做多只能选 's' 个   
  比如我们算 f[j] 的时候, 假设 s 等于 3 求的其实是 窗口内 3 个里面的最大值
  每次 j 减去一个 v, 窗口就往前移动一下.

  式子展开(竖着看的话)每一项都比前一项多了一个 w,所以我们还要加上一个偏移量w
  对于每一项我们可以发现, 求的都是长度为 s 的窗口的最大值
  ps:假设我们要算 r+2v 的最大值时, 那就要从前 i-1 件方案中选择,
     也就是枚举 r+2v 的前 3 项, 边界处会变成负数, 所以需要特判一下
     当前面不足 s 个时, 有多少就算多少
  
  f[i,j] 求的是从 j-v 开始, 往前面的 s 连续个数的最大值, 求的都是前面 s 个数的最大值
  每次求的都是长度为 s 的窗口内的最大值 
```

######为什么求的是前 S 项
```c++
大体思路:
  首先先不考虑体积不够用(sv>j)的情况下, 那么我们算 f[i,j] 的时候用的就是
    f[i-1,j]+w, f[i-1,j-2v]+2w, f[i-1,j-3v]+3w,...,f[i-1,(s-2)v]+(s-2)w + f[i-1,j-(s-1)v] + (s-1)w, f[i-1,j-sv] + sw
  在算 f[i-1,j-v] 的时候, 用的就是
                f[i-1,j-v], f[i-1,j-2v]+w, f[i-1,j-3v]+2v,...,f[i-1,j-(s-1)v]+(s-2)w, f[i-1,j-sv]+(s-1)w, f[i-1,j-(s+1)v]+sw

  所以我们每次算的都是前 s 个的最大值 
```
######偏移量
```c++
通过上述式子展开, 我们可以发现 f[i,j] 加的是 w, 2w,..,sw, f[i,j-v] 加的是 0, w, .. sw
所以要加上 "偏移量"因为我们求的是所有值的 "相对大小" 虽然在每一项里面加的 "绝对的值" 是不一样的
但是在相同的一行里, 后面一项比前面一项多了一个 w

      ——|————|————|————|————|————|————|————|————|——    
        r   r+v  r+2v r+3v r+4v r+5v ...  j+2v  j+v 
         -w    -w   -w   -w   -w        
从数轴上看, 从前往后看, 其实就是加了一个等差数列, 所以我们在单调队列中插入的时候也要体现这个优势
加上这个等差数列即可
  每一项第一项减去0*w, 第二项减去w
    r-0w, r-w, r-2w, 每次减去一个下标*w
```
```c++

#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int MAXN = 20010;

int n, m;
int f[MAXN], g[MAXN], q[MAXN];

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; ++ i)
    {
        int v, w, s; cin >> v >> w >> s;
        memcpy(g, f, sizeof g);
        for (int r = 0; r < v; ++ r)    // 枚举余数, 余数最大是 v(每行都有一个物品)
        {
            int hh = 0, tt = -1;
            for (int k = r; k <= m; k += v) // 固定住余数从前往后一次枚举每个值是多少, 枚举 r + ?v
            {
                if (hh <= tt && q[hh] < k - s * v) hh ++ ;  // 划出窗口了
                // 去掉单调队列末尾比当前元素小的, 根据两个元素相对r的位置算偏移量
                // 同一窗口内, j, j+v, j+2v后面加的w数量依次递减, 所以距离j越远, 相对减去的 w倍数越大
                // 算出(q[tt]-j)/v个w, 左边的是队尾的元素右边的是当前元素 
                while (hh <= tt && g[q[tt]] - (q[tt] - r) / v * w <= g[k] - (k - r) / v * w) tt -- ;
                q[ ++ tt] = k;    // 把当前元素下标插入单调队列
                // 计算 f[k], max 左边为不选, 右边为单调队列最大值, 加上相对k的偏移量
                if (hh <= tt) f[k] = max(f[k], g[q[hh]] + (k - q[hh]) / v * w);
            }
        }
    }
    cout << f[m] << endl;
    return 0;
}


```
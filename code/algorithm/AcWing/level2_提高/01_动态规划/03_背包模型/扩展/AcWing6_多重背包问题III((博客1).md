```
1.多重背包问题是第一维循环体积, 第二维循环物品, 第三维重循环决策(选几个) 0~s 一共 s+1 种决策
2.我们观察这 s+1 种决策的性质, 在循环体积的时候将所有体积归类, 根据体积 j 将所有体积归个类
3.如何归类 ? 按照体积 j mod v 的余数归为若干类
    - 体积 j 把所有 mod 0 的归到一类, 把所有 mod 1 的归到一类, 按照体积 mod v 的余数分成若干类
        v 类两两之间是没有交集的, v 类之间相互独立, 毫无影响, 所有加到一块就是全集
    - 为什么会出现这种现象 ? 
        j 只会从 j-kv 转移过来, 它只会从和它余数相同的 j 个集合中转移
```
```
"多重背包" 问题, 是物品个数是复数个, 但又不是无限个

当作"01背包"来理解, s个物品当成s次 01背包 操作. 然后优化的话通过二进制来优化

当作"完全背包"来理解, 就是有数量限制的完全背包, 而这个数量限制就可以理解成滑动窗口的宽度. 然后优化通过单调队列来优化
队列的单调性就是基于 f[i][j] = max(f[i-1][j], f[i-1][j-v]+w,...,f[i-1][j-k*v] + k*w), 要将前 i-1 个物品的方案基础上不停尝试放入第i个物品
遍历取最大值. f[i-1][j-k*v]+k*w 表示, 总空间是j, 有且仅有k个物品i, 其余空间通过前 i-1 个物品填充的最大价值

"多重背包因为有数量限制, 向前遍历的个数k是受到数量s限制的"
所以要将max中的每个元素f[i-1][j], f[i-1][j-v]+w,...,f[i-1][j-k*v]+k*w, 通过维护单调队列, 来获得当前窗口宽度 s 范围内的最大值
并且在 j=j+v 后, 队列中所有元素对应状态与当前背包空间差增加了v, 可以多放一个物品i, 每个元素对应的价值增加w, 全部都加一个w, 所以单调性不发生任何变化.
两种优化可以理解成两种思路的进化路线.
```
***

#       博客:
```
根据状态转移方程 dp[i][j] = max(dp[i - 1][j - k * (v)] + k * w) 0<=k<=s (此处不考虑体积不足情况)
可知dp[j]是由 间隔为 v 的值转移过来的.
那么根据 j%v 的余数划分等价类, dp[j] 就只能由同一等价类转移过来
(依靠划分等价类将不相邻的区间,变成逻辑相邻的区间,就可以套用单调队列进行优化)
由

dp[i][j   ] = max{                               dp[i-1][j]   , dp[i-1][j-v]+ w, dp[i-1][j-2v]+2w +......+ dp[i-1][j-(k-2)v]+(k-2)w, dp[i-1][j-(k-1)v]+(k-1)w, dp[i-1][j-kv]+kw}; 
dp[i][j+ v] = max{               dp[i-1][j+v]  , dp[i-1][j]+ w, dp[i-1][j-v]+2w, dp[i-1][j-2v]+3w +......+ dp[i-1][j-(k-2)v]+(k-1)w, dp[i-1][j-(k-1)v]+(k  )w                  };
dp[i][j+2v] = max{dp[i-1][j+2v], dp[i-1][j+v]+w, dp[i-1][j]+2w, dp[i-1][j-v]+3w, dp[i-1][j-2v]+4w +......+ dp[i-1][j-(k-2)v]+(k  )w};

可知:
    越靠前的项增加的w越多
    j每增加一个v时,原集合所有元素需增加一个w
    可以运用滑动窗口,单调队列解决

    如何解决每次增加w问题?
    我们只需知道哪项最大,单调队列可以只用维护相对大小.
将j离t(令t同一等价类首元素)越近增加的w越多, 每多间隔一个v, 增加会少一个w
转化为, 离f越近减去w越少, 减少 (j - t)/v个w.
那么同一集合元素其相对大小不变.例子如下:
令v = 3, s = 3可知
f[0 ] = f[0 ]
f[ v] = f[ v], f[0 ]+w
f[2v] = f[2v], f[ v]+w, f[0 ]+2w
f[3v] = f[3v], f[2v]+w, f[ v]+2w, f[0]+3w
f[4v] = f[4v], f[3v]+w, f[2v]+2w, f[v]+3w

令
f[0 ] = f[0 ]
f[ v] = f[ v] - 1w
f[2v] = f[2v] - 2w
f[3v] = f[3v] - 3w
f[4v] = f[4v] - 4w

则原式变化为 
f[0 ] = f[0 ]
f[ v] = f[ v]- w, f[0 ]
f[2v] = f[2v]-2w, f[ v]- w, f[0 ]
f[3v] = f[3v]-3w, f[2v]-2w, f[ v]- w, f[0]
f[4v] = f[4v]-4w, f[3v]-3w, f[2v]-2w, f[v]-w

对比
f[3v] = f[3v]   , f[2v]+ w, f[v]+2w, f[0]+3w
f[3v] = f[3v]-3w, f[2v]-2w, f[v]- w, f[0]
可得:f[3v]对应状态集合中的相对大小并未改变  -> 其实就是减去一个等差数列
```
```
   上课笔记:
            对于每个余数分别去单独考虑(因为每个余数之间相互独立)
            f[j] = f[j-v]+w, f[j-2*v]+2w,...,f[j-kv]+kw  
            然后我们发现在所有 和 j mod v 余数相同的体积中
            这一段是连续的, 因为公差是 v. 所以我们在算 j 的时候, 
            也就是算前 k-1 个数, 从前 k-1 个数中挑选最大值
            然后我们在看 f[j+v] 时, 实际上就是把框后移动了一位, 但框里还是有 k 个数
            所以这就变成了一个经典的单调队列问题, 给一个序列动态求出所有长度是 k 的框的最大值
            f[j] =           f[j-v]+w, f[j-2*v]+2w,...,f[j-kv]+kw
            f[j+v] = f[j]+w, f[j-v]+2w,...,f[j-(k-1)v]+kw
            也就是说在 f[j] 展开的基础上每个数多加一个v, 也就是在算 f[j+v] 时每个数都会加上一个 w
            再将 f[j] 减去 kw
            f[j] - kw
            例: f[0]
                f[v]-w
                f[2v]-2w
                f[3v]-3w 
                ... 
            (k 指 j 数字处在一个 mod v 值为 (j%v) 的数字集合中排第 k 个)
            因为在比较时候越往前加的 w 越多, 所以减去一个等差数列即可
```
```c++
#include <iostream>
#include <cstring>

using namespace std;

const int MAXN = 20010;

int n, m;
int q[MAXN], g[MAXN], dp[MAXN];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; ++ i)
    {
        int v, w, s; cin >> v >> w >> s;
        memcpy(g, dp, sizeof dp);

        // g为dp[i-1], dp为dp[i]
        for (int j = 0; j < v; ++ j)        // 枚举余数即等价类  
        {
            int hh = 0, tt = -1;
            for (int k = j; k <= m; k += v) // 枚举同一等价类的背包体积
            {
                dp[k] = g[k];
                if (hh <= tt && k - s * v > q[hh]) hh ++ ;   // 弹出不合法的队头信息
                // tt >= hh 是单调队列非空成立条件
                // k-sv > q[hh]
                // 该单调队列要维护一个不超过 s 的集合
                // 如果当前编号-队列最大容积(间隔v 容积s * v) > 首元素, 则需将首元素出队列
          
                if (hh <= tt) dp[k] = max(dp[k], g[q[hh]] + (k - q[hh]) / v * w);
                // g[q[hh]]:首元素是放置物品中的最大, 需要和不放物品值进行比较
                // q 队列实际放的是位置, 位置差比上 v 就是放置物品的数量
                // (背包体积-物品体积)/体积*价值
               while (hh <= tt && g[q[tt]] - (q[tt] - j) / v * w <= g[k] - (k - j) / v * w) tt -- ;
                // (编号-j)/ v * w是上面转化的条件
                
                q[ ++ tt] = k;// 将当前数插入队列
                // 插入队列的实际是位置而不是数值
                // 因为我们还需要位置差信息
            }
        }
    }
    cout << dp[m] << endl;
    return 0;
}
```
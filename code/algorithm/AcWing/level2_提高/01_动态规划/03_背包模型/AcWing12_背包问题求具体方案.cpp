// 本题求的是"最优方案总数"
// 可以利用 "状态转移拓扑图" 找出所有 "最优解" 的 "状态转移路径",从而求解出方案数
// 也可以在求dp的过程当中记录每一步的选择是什么, 新开一个数组g[i,j]存储选择的是第一个状态还是第2个状态
// 
// 所谓求"具体方案"其实就是判断每个物品是否被选
// 求f[n,m](终点), 其实就是看每一步如何决策从起点来到终点(如何从f[i,j]=max(f[i-1,j],f[i-1,j-v]+w)来到f[n,m])
// 也就是要倒推出来, 状态转移方程中, 每次的抉择是第一项还是第二项
//          ps: "动态规划问题" 求方案其实对应的是 "最短路问题", 我们不仅要输出最短路的长度也要输出最短路的路径
//              是求从决策中哪条路径最终走到f[n,m]的
//
// 如何字典序最小:
//      贪心, 三种情况:
//          - 只能选 必选
//          - 只能不选 必不选
//          - 可选可不选 必选
// 为什么有三种情况? 因为转移过程中只有这三种情况, 详细看转移
//
// 但是求"具体方案"的作法是从n往前推, 但是得到字典序最小的方案是从前往后推, 这两个是反着的
// 为了能够从前往后推, 只需要在求解01背包时, 从后往前推就行了, 我们将循环的顺序变成从后往前
#include <iostream>

using namespace std;

const int N = 1010;

int n, m;
int v[N], w[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    // 先读进来再翻着做才是反转过来去做
    for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i];
    // 求字典序列,从后往前推,倒着求一遍背包
    // 从最后一个物品开始求, 这样字典许从前往后求就没问题了
    for (int i = n; i >= 1; i -- )
        for (int j = 0; j <= m; j ++ )
        {
            f[i][j] = f[i + 1][j];
            if (j >= v[i]) f[i][j] = max(f[i][j], f[i + 1][j - v[i]] + w[i]);
        }
    
    // 从前往后依次看, 每个物品是否需要选则
    // f[1][m] 是最大值也就是答案(因为我们是从后往前推的)
    // 所以我们从最大的值开始找, 也就是1位置开始
    int j = m;
    for (int i = 1; i <= n; ++ i)
        if (j >= v[i] && f[i][j] == f[i + 1][j - v[i]] + w[i])      
        {
            // f[i + 1][j - v[i]]: 是前一项未转移的状态, 
            // 如果前一项+w等于当前项,那么就是从他转移过来的 
            // 可以用一个变量记录路径
            cout << i << ' ';
            j -= v[i];
        }
        // else 如果不需要加上权重也相等那就是不要选择
    return 0;
}
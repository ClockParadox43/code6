
// 这是两个经典DP模型的结合版:
// LIS (最长上升子序列, Longest Increasing Subsequence)
// LCS (最长公共子序列, Longest Common Subsequence)
// LCIS(最长公共上升子序列, Longest Common Increasing Subsequence)
// LCIS 也是一个相当经典的DP模型, 他的 状态分析 是 LIS 与 LCS 的结合
//
//
//                集合: 所有第一个序列的前 i-1 个字母, 和第二个序列的前 j 个字母构成的 
//              /       且以 b[j] 结尾的公共上升子序列
//      状态表示
//   /          \ 
// DP             属性: Max
//   \  
//     状态计算  f[i,j]
//
//  所有包含 a[i] 的公共上升子序列                                                      
//          ______\__________________|________
//         |    |    |    |   |      |        | -> 所有不包含  
//         |null|b[1]|b[2]|...|b[j-1]|f[i-1,j]|    a[i] 的公共上升子序列
//         |____|____|____|___|______|________|
//                |                  |
//                v                  |
//       由第 1 个序列的前 i-1 个字母 (因为 a[i] 已被使用, 所以只能从 a[1~i-1] 中选择)
//                                    我们想表达的是已经将 a[i] 和 b[j] 匹配的情况, a[i] 不能被重复使用, 所以只能用
//                                    f[i-1,j] 来更新...(视频中写的是第 1 个序列的前 i 个字母)
//                                    包含 a[i] 的意思是: 当前 a[i] 和 b[j] 相等所以有 + 1, 
//                                    但万一 f[i,k] 已经使用了 a[i], 那就错了(多加一个1, a[i] = b[j], a[i] = b[k])
//              
//       和第 2 个序列的前 1 个字母
//       且以 b[1] 结尾的所有的公共上升子序列.
//
//  a[i] = b[j]解释: 
//      因为 a[i] 是公共的, 并且状态定义的 f[i,j] 存储的时候以 b[j] 结尾(为什么要以 b[j] 结尾? 下面有解释), 所以有 a[i] = b[j]
//
//  a[i] 是否会被考虑进去?
//    - 因为左边的集合有 a[i] = b[j], 那么第一个序列的前 i 个字母中的第 i 个字母一定是严格大于第二个序列的前 j-1 个字母
//      实际上第 i 个字母永远不会被考虑进去, 所以写 i 也是对的, 但是并不严谨 
//
// ps:
//  其实只划分为两部分, 所有包含 a[i] 的公共上升子序列, 和所有不包含 a[i] 的公共上升子序列
//  但是由于 "所有包含 a[i] 的公共上升子序列" 这部分的状态不好直接求(没有一种状态直接表示它),
//  所以继续分解, 直到分解到能计算位置, 因为理论上说一定是能分解到能算为止的
//  因为最差的情况下 "每一种方案都是一种状态". 每一种方案从实际意义去出发即可
// 
// 公共子序列是只包含了 4 种情况(两个序列包含/不包含就是 4 种), 
// 为什么要已 b[j] 结尾, 考虑的是最长上升子序列问题, 因为我们在接的时候要考虑上一个数是多少
// 才能考虑当前数是否能接过去
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 3010;

int n;
int a[N], b[N];
int f[N][N];


int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; ++ i) scanf("%d", &a[i]);
    for (int i = 1; i <= n; ++ i) scanf("%d", &b[i]);

    for (int i = 1; i <= n; ++ i)
        for (int j = 1; j <= n; ++ j)
        {
            f[i][j] = f[i - 1][j];              // 没有包含 a[i] 的情况
            if (a[i] == b[j])                   // a[i] 和 b[j] 是并集
            {
                f[i][j] = max(f[i][j], 1);      // 固定了 a[i] 后, 求以 b[j] 结尾的最长上升子序列 
                for (int k = 1; k < j; ++ k)
                    if (a[i] > b[k])
                        f[i][j] = max(f[i][j], f[i - 1][k] + 1); // f[i - 1][k]: a[i] 已经被使用, 所以只能从 i-1 中选则, 当前的序列和之前的序列做对比
            }                                                    // f[i][j] : 以 b[j] 结尾可以作为候选的序列
        }

    int res = 0;
    for (int i = 1; i <= n; ++i) res = max(res, f[n][i]);

    printf("%d\n", res);
    return 0;
}
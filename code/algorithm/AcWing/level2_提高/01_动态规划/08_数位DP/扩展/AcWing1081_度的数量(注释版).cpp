// [X,Y]中使枚举出恰好等于K个互不相等的B的次幂之和的数
// 其实等价于求由K个1组成的B的次幂之和的数

// 第一步:先将数x转化为B进制
// 第二步:分类讨论, 既然每一位上的数都已给定, 我们称之为每一位的"限定值"都以给出
//        这样每一位上可取的数的大小就确定了, 每一位分两种情况
//          1.取限定值
//          2.取0~限定值-1中的任意的数
// ps:对于本题, 这里每个数用不到限定值, 只有限定值为1才会用到, 因为本题求的数K位上填1
//    其他位上填0, 根本不会出现其他数字, 所以当出现 > 1 的数字的时候, break
// 对于B进制数(共n位), 从最高位(第n位)开始遍历每1位, 对于第i位, 
// last表示第i位之前的所有位取过的1的个数, 第i位上的数字x有三种情况:
//      1. 限定值x=0: 此时第i位只能取0, 不影响1的个数, 后面所有位可以取k-last个1, 当此位取1时
//         后面所有位只能取k-last-1个1
//      2. 限定值x=1: 此时可以取0或1. 当此位取0时, 后面的所有位可以取k-last个1; 
//                    当此位取1时, 后面所有位只能取k-last-1个1
//      3. 限定值大于1: 当前位取0或1时, 处理同2; 其他值不能直接取, 在本题中没有意义
//
// 因为从最高位开始枚举的, 当n为最高位时, n > 任意最高位0~an-1的数
// 所以无论怎么枚举都不会超过, 所以可以直接求出
// 而右边需要通过枚举次高位继续分类讨论
// 当全部枚举完, 可以发现树的右边那条链组成的树就是N自己
#include <iostream>
#include <vector>

using namespace std;

const int N = 35;

int f[N][N];    // f[a][b]代表从a个数中选b个数的方案数, 即组合数
int K, B;       // K是能用1的个数, B代表B进制

// 预处理组合数
void init()
{
    for (int i = 0; i < N; ++ i)
        for (int j = 0; j <= i; ++ j)
            if (!j) f[i][j] = 1;
            else f[i][j] = f[i - 1][j] + f[i - 1][j - 1];
}

// 求[0,n]中满足条件数的个数
// "满足条件数的个数"指:一个数的B进制表示, 其中有K位数1, 其他位全是0
int dp(int n)
{
    if (!n) return 0;   //  如果上界n是0, 返回0种
    vector<int> nums;   // 存在n在B进制下的每一位   
    // 把n在B进制下的每一位单独拿出
    while (n) nums.push_back(n % B), n /= B;
    
    int res = 0;    // [0,n]中有多少个合法的数
    
    // last 在数位dp中存储的数: 右边分支往下走的时候保存前面的信息
    // 遍历当前位的时候, 记录之前那些已经占用多少个1, 那么当前还能用1的个数就是k-last个1
    int last = 0;
    
    // 从最高位开始遍历每一位
    for (int i = nums.size() - 1; i >= 0; -- i)
    {
        int x = nums[i];    // 取当前位上的数
        
        // 只有x大于0的时候才可以讨论左右分支
        if (x > 0) 
        {
            // 当前位填0, 从剩下的所有位(共有i位)中选择K-last个数
            // 对应于:左分支中填0的情况, 合法
            res += f[i][K - last];  
            
            if (x > 1)
            {
                // 当前位填1, 从剩下的所有位(共有i位)中选K-last-1个数
                // 对应于:左分支填1的情况, 合法
                if (K - last - 1 >= 0) 
                    res += f[i][K - last - 1];  // i个数中选K-last-1个数填1的组合数数多少
                
                // 对应于: 左分支中其他情况(填>1的个数)和此时右分支的情况(右侧此时也>1), 不合法
                // 直接break
                break;
            }
            // 上面统计完了"左分支"的所有情况, 和"右分支"大于1的情况
    
            // 这个else, 是 x==1
            // 对应于: 右分支为1的情况, 即限定值位1的情况, 也就是左分支只能取0
            //         此时的处理是, 直接放到下一位来处理
            // 只不过下一位可使用的1的个数会少1, 体现在代码上是last+1
            else
            {
                ++ last; 
                if (last > K) break;
            }
    
        }
        // 上面处理完了这棵树的所有左分支, 就剩下最后一种右分支的情况
        // 也就是遍历到最后1位, 在vector中就是下标为0的地方: i == 0
        // 并且最后1位取0, 才算做一种情况, res++。因为最后1位不为0的话, 已经被上面的ifelse处理了
        if (!i && last == K) ++ res;
    }
    return res;
    
}

int main()
{
    init();
    int l, r;
    cin >> l >> r >> K >> B;
    cout << dp(r) - dp(l - 1) << endl;
    return 0;
}


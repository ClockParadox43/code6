// 如果存在一个限制我们不用第i-2层的状态, 我们应该如何转移
//      分析: 1.如果我们只用上一层的状态, 在我们选择第i家店铺的时候是不能知道
//              上一家店铺在最优解中是否被打劫过
//            2.因为上一家店铺状态不确定, 所以我们可以把f[i]的状态分解成两个状态
//              使得当前层可以递推到下一层
// 
//                  / f[i][0]: 0 未选择最后一个店铺
//              f[i]
//                  \ f[i][1]: 1 选择了最后一个店铺
// 
//             如果当前选择0这个状态, 那么他的下一个选择就有两种状态
//                  - 不选择下一个店铺
//                  - 选择下一个店铺, 状态就会状态就会置成1
//             如果当前选择1这个状态, 那么他的下一个选择就有1种状态
//                  - 不选择下一个店铺
//                  x 如果选择了下一家店铺, 就会出现两个连续的1, 这是不被允许的
//
//             所以状态机最终的状态就是两个点三条边
//
// 例:RSA秘钥之所以能奏效的原因
//      我们会先想到两个私钥, 私钥是两个很大的质数 p q, 他们的乘积作N为公钥可以放出去
//      破解难点是因为p,q很大, 所以N自然也很大, 目前没有一个高效的算法在一定时间内 
//      分解p,q的乘积
//      一个全部混在一起的状态就相当于N的状态, 
//      而状态机就相当于那个p和q的状态, 一堆状态在p这边, 另一堆状态在q这边
//      相互之间的关系也很明确
#include <iostream>
#include <cstring>

using namespace std;

const int N = 100010, INF = 0x3f3f3f3f;

int T, n;
int w[N], f[N][2];

// 状态表示f[i][j]: 走了i步状态为j的最大值
int main()
{
    cin >> T;
    while (T -- )
    {
        cin >> n;
        for (int i = 1; i <= n; ++ i) cin >> w[i];
        // 给定一个虚拟入口, 入口只能到0或者1
        // 因为我们不能是选择一个不存在的物品
        // 所以入口的状态1只能给负无穷
        f[0][0] = 0, f[0][1] = -INF;
        for (int i = 1; i <= n; ++ i)
        {
            f[i][0] = max(f[i - 1][0], f[i - 1][1]);
            f[i][1] = f[i - 1][0] + w[i];
        }
        cout << max(f[n][0], f[n][1]) << endl;
    }
    return 0;
}
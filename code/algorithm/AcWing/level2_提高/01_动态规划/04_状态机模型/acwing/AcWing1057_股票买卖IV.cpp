// 状态机:
//  状态表示f[i][j][s]: 只考虑前i步状态已经进行完j次交易状态为s的最大收益
//        - f[i][j][0]: 只考虑前i天已经进行了j次交易并且手中无货的状态的最大收益
//        - f[i][j][1]: 只考虑前i天且已经进行完j-1次交易
//                      正在进行第j次交易并且手中有货的状态的最大收益
//             属性: max
//  状态计算f[i][j]:
// 
//  手中无货的情况为0, 手中有货的情况为1 
// 手中有货,卖出, 会跳到手中无货状态
// 这句话意味着:
// 手中无货状态来自手中有货状态卖出(进行完j次交易), 来自手中无货不买(进行完j次交易)
//      f[i][0] = max(f[i - 1][j][1] + w[i], f[i - 1][j][0])
//
// 手中有货 来自 手中无货状态买入(进行了半次交易), 和手中有货状态(进行完了j次交易) 
//      f[i][1] = max(f[i - 1][j - 1][0] - w[i], f[i - 1][j][1])    -> 为什么 0-w[i], 因为买入是一个支出状态
// ps!!!!:本题买入卖出记作一次交易
#include <iostream>
#include <cstring>

using namespace std;

const int N = 1e5 + 4, M = 104, INF = 0x3f3f3f3f;
int n, m, limit;
int f[N][M][2];
int w[N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; ++ i) cin >> w[i];
    
    memset(f, 0xcf, sizeof f);
    // 初始化:如果一次交易都没有进行(j=0)就是手中无货, 也就是合法状态
    for (int i = 0; i <= n; i ++ ) f[i][0][0] = 0;
    for (int i = 1; i <= n; ++ i)
        for (int j = 1; j <= m; ++ j)
        {
            f[i][j][0] = max(f[i - 1][j][0], f[i - 1][j][1] + w[i]);
            f[i][j][1] = max(f[i - 1][j][1], f[i - 1][j - 1][0] - w[i]);
        }
    
    // 输出的时候枚举下到底进行了多少次交易(本题没有明确一定要进行k交易)
    int res = 0;
    // 因为一定是完整的交易, 所以手中无货, 状态为0 
    for (int i = 0; i <= m; ++ i) res = max(res, f[n][i][0]);
    cout << res << endl;
    return 0;
}
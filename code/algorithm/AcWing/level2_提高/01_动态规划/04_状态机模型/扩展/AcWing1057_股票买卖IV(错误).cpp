//  手中有货的情况只能从手中无货的情况转移过来:
//          1.卖出当前股票 f[i][1] = f[i - 1][0] + w[i]
//          2.不卖出当前股票 f[i][1] = f[i - 1][0]
//                  - f[i][1] = max(f[i - 1][0] + w[i], f[i - 1][0])
//  手中无货的情况买入情况只能从手中无货情况转移过来        -> 这里是错误的, 因为, 手中无货的情况可以来自手中有货卖出的情况
//          1.买入当前股票: f[i][0] = f[i - 1][0] - w[i]
//  不买当前股票: 手中无货可以从手中有货和手中无货的情况下转移过来
//          2.不买当前股票f[i][0] = f[i - 1][0], f[i - 1][1]
// 
//  =============== 错误分析 ==============
//
// 状态机:
//  状态表示f[i][j]: 当前第i步状态为j的最大收益
//             属性: max
//  状态计算f[i][j]:
// 
//  手中无货的情况为0, 手中有货的情况为1 
// 手中有货,卖出, 会跳到手中无货状态
// 这句话意味着:
// 手中无货状态来自手中有货状态卖出, 来自手中无货不买
//      f[i][0] = max(f[i - 1][1] - (0 - w[i]), f[i - 1][0])
//
// 手中有货 来自 手中无货状态买入, 和手中有货状态 
//      f[i][1] = max(f[i - 1][0] + (0 - w[i]), f[i - 1][1])    -> 为什么 0-w[i], 因为买入是一个支出状态

#include <iostream>

using namespace std;
const int N = 1e5 + 4, INF = 0x3f3f3f3f3f;

int n, k;
int f[N][2];
int w[N];

int main()
{
    cin >> n >> k;

    for (int i = 1; i <= n; ++ i) cin >> w[i];
    // 入口:手中无货物
    // 不能选择一个不存在的物品, 因此手中有货状态设置为负无穷
    int f[0][0] = 0, f[0][1] = -INF;
    
    for (int i = 1; i <= n; ++ i)
    {
        f[i][0] = max(f[i - 1][1] - w[i], f[i - 1][0]);
        f[i][1] = max(f[i - 1][0] + w[i], f[i - 1][1]);
    }
    cout << max(f[n][0], f[n][1]) << endl; 
    return 0;
}
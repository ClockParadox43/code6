// 其实经过同一个点虽说会被枚举, 但是你总会找到一个另一条路径不经过这个点但是却比这个点多
// 所以虽然枚举了, 但是没有意义, 他会被其它的更新掉
//
// 证明传纸条为何可以使用方格取数的代码
//      - 因为两个点相交, 这个点的值只能加一次, 然而我们肯定能找到一条绕过这个点走到下个点的路径,
//        这条路径一定是大于之前相交路径的
//
// 数学表达就是:
//      - 两条路径在一个点, 那么在这个点加的值就是0+g[i,j] 但是我们可以让其中一条路径绕过这个点再走到这个点的下一个点 
//        那么加的值应该是 g[i,j-1]+g[i,j] 因为是非负数, 所以我们可以找到一条大于等于之前有相交点的路径. 
//        那么这个有相交点的一定不是最优解; 
//        即便这条路径是最优解也有另一条最优解和这个路径和一样, 
//        但是我们只需要输出路径和就可以了, 最优解路径有可能是有相交点的,   
//        但是也有另一个最优解没有相交点，那么我们输出的路径和肯定可以是一条没有相交点的最优解
#include <iostream>

using namespace std;

const int MAXN = 55;

int n, m;
int w[MAXN][MAXN];
int f[MAXN << 1][MAXN][MAXN];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; ++ i)
        for (int j = 1; j <= m; ++ j)
            cin >> w[i][j];
    
    // k 是横纵坐标之和, 所以 i 必须严格小于 k
    for (int k = 2; k <= n + m; ++ k)
        for (int i = 1; i < k; ++ i)
            for (int j = 1; j < k; ++ j)
            {
                int &v = f[k][i][j];
                // 纵坐标: k-i/k-j 
                // t: 代表其中一条路径到值
                int t = w[i][k - i];        
                if (i != j) t += w[j][k - j];
                v = max(f[k - 1][i - 1][j - 1], v);
                v = max(f[k - 1][i - 1][j], v);
                v = max(f[k - 1][i][j - 1], v);
                v = max(f[k - 1][i][j], v);
                v += t;
            }
    
    printf("%d\n", f[n + m][n][n]);
    return 0;
}
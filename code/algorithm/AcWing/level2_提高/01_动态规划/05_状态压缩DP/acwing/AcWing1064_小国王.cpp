// 当前行, 只和上一行有关系, 所以我们只需要考虑上一层的状态
// 所以我们就可以根据上一层的状态, 把我们第i行的这一类看作若干个集合
// 其实这里是和状态机是相似的, 当前i行的最后一个状态无法表示时, 将前i行的最后一个状态分解
// 状态机是根据时序拉进行分解, 而状态压缩是根据集合或者二进制来进行分解
//
// 状态表示 f[i,j,s] 
//      - 集合: 所有只摆了前i行, 并且已经放了j个棋子, 并且第i行摆放的状态是s的所有方案数
//      - 属性: 方案数          
//      (该思想其实是将一堆方案归为一类的思想, 将所有一类的方案划分到一块去)
//      ps:忘记什么意思可以将变量带入读一遍
//
// 1<=n<=10
// 0<=k<=n^2
// 时间复杂度计算: 状态数量 * 状态计算的计算量
// 因为是将每i行划分为一个集合, 国王数量 <=n^2, 所有合法的数量
// S:合法状态数量记作S, Sh:每个状态所有合法的转移数量
// 所以 10 * 100 * S * Sh, 状态为指数级别
// 10 * 100 * 2^10 * 2^10 = 10^9

#include <iostream>
#include <vector>

using namespace std;

typedef long long ll;
// M:状态数量, K:国王数量
const int N = 12, M = 1 << 10, K = 110; 
int n, m;
vector<int> st;        // st:表示所有和法状态 
vector<int> head[M];   // 每一状态所有可以转移到的其他状态
ll f[N][K][M]; 
int cnt[M];     // cnt:每个状态里面1的数量
                     

bool check(int state)
{
    for (int i = 0; i < n; ++ i)
        if((state >> i & 1) && (state >> i + 1 & 1))
            return false; // 如果存在连续两个1的话就不合法
    return true;        
}

// 这里就是计算某个数二进制里面1的个数
int count(int state)
{
    int res = 0;
    for(int i = 0;i < n;i ++ ) res += state >> i & 1;
    return res;
}

int main()
{
    cin >> n >> m;
    
    // 预处理出所有的合法状态
    for (int i = 0;i < 1 << n; ++ i)
        if(check(i))    // 如果不存在连续的2个1
        {
            st.push_back(i);
            cnt[i] = count(i);      // 每个状态里面1的数量
        }
    
    // 预处理所有合法状态的合法转移
    for (int i = 0; i < st.size(); ++ i)
        for (int j = 0; j < st.size(); ++ j)
        {
            int a = st[i], b = st[j];   // a:表示第一个状态, b:第二个状态
            
            // 这里是建立一个不同状态之间的转移关系
            // 先预处理一下哪些状态和哪些状态之间可以转移
            // a 和 b 的交集必须要是空集, 并集不能包含连续两个1
            if (!(a & b) && check(a | b))
                head[i].push_back(j);       // 如果b是合法状态将b添加至a可以转移到的状态集合中
            // ps:此时说明下标为i的状态能接在下标为j的状态后(即下一行), 则说明下标为i的状态能由下标为j的状态转移而来
            //    即将下标j存进head[i] ~
        }

        // 前0行已经摆完了, 一个国王都没有摆的情况, 0 这个状态是合法的
        // 方案数为1 (在棋盘外面)
        f[0][0][0] = 1;
        // 从前往后枚举每一种状态
        for (int i = 1; i <= n + 1; ++ i)
            for (int j = 0; j <= m; ++ j)            // j从0到m, m代表国王的数量
                for (int a = 0; a < st.size(); ++ a) // 然后我们来枚举一下所有的状态, a表示第i行的状态
                    for (int b : head[a])            // 枚举所有a能到的状态
                    {
                        // c:判断a中1的个数
                        int c = cnt[st[a]];
                        if (j >= c)       
                        { 
                            // j是必须要大于等于c的, 当前这行摆放的国王数量一定要小于等于我们整个的上限
                            f[i][j][a] += f[i - 1][j - c][b]; // 转移的话就是f[i][j][a]+=f[i-1][j-c][b], 然后从b转移过来
                        }
                    }
    
    // 最后的答案 f[n][m][] 应该由枚举得到
    // 小技巧: 就我们在枚举i的时候, 枚举到n+1就可以了
    // 一共摆到了第n+1行, 然后m, 然后0, 因为第n+1行一个都没摆
    // f[n+1][m][0]已经在这个循环里面被循环算出来
    cout << f[n + 1][m][0] << endl;
    return 0;
}  
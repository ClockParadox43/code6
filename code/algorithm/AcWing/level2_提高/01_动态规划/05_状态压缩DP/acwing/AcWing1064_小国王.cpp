// 当前行, 只和上一行有关系, 所以我们只需要考虑上一层的状态
// 所以我们就可以根据上一层的状态, 把我们第i行的这一类看作若干个集合
// 其实这里是和状态机是相似的, 当前i行的最后一个状态无法表示时, 将前i行的最后一个状态分解
// 状态机是根据时序拉进行分解, 而状态压缩是根据集合或者二进制来进行分解
//
// 状态表示 f[i,j,s] 
//      - 集合: 所有只摆了前i行, 并且已经放了j个棋子, 并且第i行摆放的状态是s的所有方案数
//      - 属性: 方案数          
//      (该思想其实是将一堆方案归为一类的思想, 将所有一类的方案划分到一块去)
//      ps:忘记什么意思可以将变量带入读一遍
//
// 1<=n<=10
// 0<=k<=n^2
// 时间复杂度计算: 状态数量 * 状态计算的计算量
// 因为是将每i行划分为一个集合, 国王数量 <=n^2, 所有合法的数量
// S:合法状态数量记作S, Sh:每个状态所有合法的转移数量
// 所以 10 * 100 * S * Sh, 状态为指数级别
// 10 * 100 * 2^10 * 2^10 = 10^9

#include <iostream>

using namespace std;

typedef long long ll;
// M:状态数量, K:国王数量
const int N = 12, M = 1 << 10, K = 110; 
int n, m;
vector<int> st;        // st:表示所有和法状态 
vector<int> head[M];   // 每一状态所有可以转移到的其他状态
ll f[N][K][M]; 
int cnt[M], id[M];     // cnt:每个状态里面1的数量
                       //  id:存这个每一个状态和这个它的下标之间的映射关系
int main()
{
    cin >> n >> m;
    
    // 预处理出所有的合法状态
    for (int i = 0;i < 1 << n; ++ i)
        if(check(i))    // 如果不存在连续的2个1
        {
            st.push_back(i);
            id[i] = st.size() - 1;  // id存的是我们这个合法状态对应的下标是多少
            cnt[i] = count(i);      // 每个状态里面1的数量
        }
    
    // 个不同状态之间的一个这个边的关系
    for (int i = 0; i < st.size(); ++ i)
        for (int j = 0; j < st.size(); ++ j)
        {
            int a = st[i], b = st[j];   // a:表示第一个状态, b:第二个状态
            
            // 这里是建立一个不同状态之间的转移关系
            // 先预处理一下哪些状态和哪些状态之间可以转移
            // a 和 b 的交集必须要是空集, 并集不能包含连续两个1
            if (!(a & b) && check(a | b))
                head[i].push_back(j);       // 如果b是合法状态将b添加至a可以转移到的状态集合中
        }

        // 前0行已经摆完了, 一个国王都没有摆的情况, 0 这个状态是合法的
        // 方案数为1 (在棋盘外面)
        f[0][0][0] = 1;
        // 从前往后枚举每一种状态
        for (int i = 1; i <= n + 1; ++ i)
            for (int j = 0; j <= m; ++ j)            // j从0到m, m代表国王的数量
                for (int a = 0; a < st.size(); ++ a) // 然后我们来枚举一下所有的状态, a表示第i行的状态
                    for (int b : head[a])            // 枚举所有a能到的状态
                    {
                        // 判断a中1的个数
                        // 我们的j必须要大于等于c对吧, j是必须要大于等于c
                        int c = cnt[state[a]];
                        if (j >= c)                           // 如果数说满足要求的话, 那么我们就可以转移了
                            f[i][j][a] += f[i - a][j - c][b]; // 转移的话就是f[i][j][a]+=f[i-1][j-c][b], 然后从b转移过来
                    }
    cout << f[n + 1][m][0] << endl;
    return 0;
}  


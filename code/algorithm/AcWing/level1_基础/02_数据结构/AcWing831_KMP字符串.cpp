// 暴力做法是将整个模板串往后移动一位, 重新开始匹配
// 但是可以发现, 其实可以不需要重新开始匹配, 因为之前已经匹配过了
// 匹配到不匹配的字符, 才会发生重新匹配这个行为, 也就是说之前是有相同字符的
// 我们不需要全部都重新匹配
// 暴力做法将模板串往后移动一位, 对应主串, 从后面一位开始匹配太慢了
// 所以我们要考虑的就是将模板串最多往后移多少就可以重新开始匹配
// 
// 核心思想:在每次失配时, 不是把 p 串往后移一位, 而是把 p 串往后移动至下一次可以和前面部分匹配的位置
//          这样就可以跳过大多数的失配步骤, 而每次 p 串移动的步数就是通过查找 next[] 数组确定的
//
// next[i]含义:以 i 为终点的后缀和从 1 开始的前缀相等, 后缀的长度最长
// 求模板串后缀和前缀相等, 相等的最大长度是多少
//
// 时间复杂度:因为主串指针没有发生回退, 模式串指针最多回退 m 次
//            所以时间复杂度是 O(N+M) -> O(N)
#include <iostream>

using namespace std;

const int N = 100010, M = 1000010;

int n, m;
char p[N], s[M];
int ne[N];

int main()
{
    cin >> n >> p + 1 >> m >> s + 1;
    // 预处理 next 数组:
    //  0 号位置代表要从新匹配, 不存储长度, 1 号位置根本就不存在前缀串所以 i 从 2 开始
    //  0 是判断是否需要重新来过的位置, 所以 j 从 0 开始, 因为是从0位置开始匹配所以i和j+1位置匹配(0位置啥也没有)   
    //  为什么是2: 因为求的是最长前缀, 起码两个字符才能有前缀 
    for (int i = 2, j = 0; i <= n; ++ i )
    {
        while(j && p[i] != p[j + 1]) j = ne[j];   // 如果前后缀不匹配 j 就一直往回退, 直到 j 为 0
        if (p[i] == p[j + 1]) ++ j;
        ne[i] = j;
    }

    // 为什么 s[i] 和 p[j + 1] 而不是 s[i] 和 p[j] 对比
    // 因为最开始在 记录 对应后缀的最长前缀 时, 就是 p[i] 和 p[j + 1] 匹配的
    // ne[i] 记录的就是这么一个规格的
    for (int i = 1, j = 0; i <= m; ++ i )
    {
        // 如果 j 还没有退回起点(退回起点就要重新开始匹配了), 并且主串不能和模板串的下一位去匹配 
        // 就要想模板串最少往后移动多少使得, 也就是让最大后缀等于前缀
        while (j && s[i] != p[j + 1]) j = ne[j];
        if (s[i] == p[j + 1]) j ++ ;
        if (j == n)     // 匹配成功
        {
            printf("%d ", i - n);       // 该题下标从 0 开始不要-1, 招到了末尾的位置, 倒着走 N 步就是开始的位置
            j = ne[j];  // 因为ne[j]求的是最大匹配所以对应最小移动, 保证不遗漏
        }    
    }
    return 0;
}
// 好像再求区间厚度问题(最多区间重叠部分)
// 可以将做个饭问题想象成活动安排问题
//      例: 有若干个活动, 第 i 个活动开始时间和结束时间是 [Si, fi], 同一个教室的活动之间不能交叠
//          求安排所有互动, 最少需要几个教室
//      分析: 有时间冲突的活动不能安排同一间教室, 与该问题限制相同, 即最小教室个数即该题答案
//      解: 我们所有开始时间和结束时间排序, 遇到开始时间就把需要的教室加1, 遇到结束时间就把需要的教室减1
//          在一系列列的需要的教室个数变化中, 峰值就是多同时进行的活动数, 也是我们最小需要的教室数
//              - 还可以用来求:最多同时进行的活动数量的时间点
// 
// ps: 线段问题和时间问题是相通的      
//     
// 思路: 一个活动开始时, 分配一间教室, 一个活动结束时, 释放一间教室, 
//       这样所需的教室数量上下浮动, 而浮动过程中的最大值就是所需教室数量的最小值
//       没结束就不释放, 结束了就把对应的教室释放, 不用管释放的是哪一间教室
//
//
// 评论: 根据区间是否能进行交叠进行开始与结束时间的离散化 -> 核心思路 
//       之前处理区间问题构建的差分数组一直不知道该怎么进行离散化来规避这个问题.
//       之前只会处理可以交叠的问题即不乘2进行处理, 如果遇到开始时间和结束时间相同则处理为可以交叠问题
#include <iostream>
#include <algorithm>

using namespace std;
const int MAXN = 1e5 + 3;
typedef pair<int, int> PII;

int n, idx;
int segs[2 * MAXN];

int main()
{
    scanf("%d", &n);

    // 里面的奇偶变换也很妙, 能同时处理左右端点标记与重合点先后排序的问题. 
    //      - 如果区间端点重合, 端点标记的奇数偶数反一下即可
    //        因为对于同一个数, 将它变成奇数比偶数大 1
    //        
    // 如果不使用这个方法的话得在重载操作符的时候处理这个问题
    for (int i = 0; i < n; ++ i)
    {
        int l, r; scanf("%d%d", &l, &r);
        segs[idx ++ ] = l * 2;     // 将左端点标记为偶数
        segs[idx ++ ] = r * 2 + 1; // 将右端点标记为奇数
    }

    sort(segs, segs + idx);
    int res = 1, cnt = 0;
    for (int i = 0; i < idx; ++ i)
    {
        if (!(segs[i] % 2)) cnt ++ ;  // 开始使用 cnt ++,
        else cnt -- ;                 // 教室使用结束了 cnt 减 1, 因为当前教室可被重复使用
        res = max(res, cnt);          // 峰值最大的就是 res(连续使用同一间教室)
    }

    printf("%d\n", res);
    
    return 0;
}
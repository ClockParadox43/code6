// 一个正整数 n 可以表示成若干个正整数之和, 形如: n = n1 + n2 + … +nk, 其中 n1 ≥ n2 ≥ … ≥ nk, k ≥ 1
// 我们将这样的一种表示称为正整数 n 的一种划分
// 现在给定一个正整数 n, 请你求出 n 共有多少种不同的划分方法
// 数据范围:
// 1 ≤ n ≤ 1000
// 例: n = 5
//     4+1, 3+2, 2+2+1, 2+1+1+1, 3+1+1, 1+1+1+1+1
// "完全背包" 做法:
//      物品和体积分别是 1~n, 求装满背包的方案数
//      因为每种物品可以使用无线次, 所以是 "完全背包" 做法
//
//
//     属性: 数量
// 状态表示: f[i][j] 表示只从 1~i 中选, 且总和是 j 的方案数
//     集合: 划分为 n 组代表符合当前体积的方案数          
// 状态转移方程: f[i][j] = f[i - 1][j] + f[i][j - i];
//
// 最开始枚举 i 为 1 的体积
// 每次从上一次(i-1)位置的方案数中累加上 j-i*k 格子的方案数, 让体积正好等于 j
// 在内层循环中, 累加上组成 j 合适的方案数
// 例子 : 当 i 为 2 的时候, j = 2, 2-2*0=2, 也就是对应 f[1][2] = 1(正上方)
//        只拿一个 2 的时候有一个方案数
//        当 k = 1 时, 2-2*1=0, 也就对应 f[1][0], 那两个 1 时候的方案数
#include <iostream>

using namespace std;

const int N = 1010, mod = 1e9 + 7;

int n;
int f[N][N];

int main()
{
    scanf("%d", &n);
    
    // 当体积为 0, 在不超过体积的情况下有 1 种装法 
    f[0][0] = 1;    
    for (int i = 1; i <= n; ++ i )      // 从体积为 1 的物品开始枚举
        for (int j = 0; j <= n; ++ j )  // 枚举所有符合体积数的情况
        {
            // f[i-1][j-i*k]:第 i 个物品选了 0 个组成 j, 也就是已经包括在不选里了
            // f[i][j]+=f[i-1][j-i*k]:f[i,j]枚举之前所有能组成j的方案, 累加进 f[i,j]
            for (int k = 0; k * i <= j; ++ k )
                f[i][j] = (f[i][j] + f[i - 1][j - i * k]) % mod;
        }
    
    // 优化:方程抵消成一维度
    // for (int i = 1; i <= n; ++ i )
    //     for (int j = 1; j <= n; ++ j )
    //         f[j] = (f[j] + f[j - i]) % mod;  

    cout << f[n][n] << endl;
    return 0;
}
// 核心思路:
// 先放横着的, 再放竖着的, 横着的摆完后就可以发现竖着的位置就剩余一种填充方案
// 竖着的也摆完后就是一种方案 
// 总方案数等于只放横着的小方块的合法方案数
// 当前摆完横着的小方块后, 用竖着的小方块塞满, 就是一种合法方案
// 1) 因此我们要判断横置小方块摆完后摆竖置小方块是否合法
// 2) 还要判断所有剩余位置是否能填充满所有竖着的小方块
// 
// 状态表示: f[i,j] 表示前 i-1 列已经摆好, 且从 i-1 列伸到第 i 列的状态是 j 的所有方案
//       
//      i-2 i-1_i___ 
//      |__|//|//|__|  该图中 i = 2, j = 11001
//      |__|//|//|__|   
//      |\\|\\|__|__|  -> k 伸出来的格子, 二进制表示 00100
//      |__|__|__|__|
//      |__|//|//|__|
//
// i-1 列到第 i 列是固定的, 那么没有固定的是 i-2~i-1
// 所以可以依据 i-2~i-1 列的状态来分割(没有固定)
// 每一个都有两种选择(伸或者不伸), 所以最坏情况是 2^n 个集合
// f[i,j] 所有集合的话它的倒数第 2 步(展开的可能性是从哪个集合展开的), 一定属于每一类之一, 那么 f[i,j] 一定是不重不漏的
// 
// 每一个集合中表示的都是具体的状态 k, 如果只是伸出来一列, 那么 k 表示的就是 00100
//
// 摆放完后, 对于第 i-1 列之前的格子来说空着的方块就固定了, 所以需要满足空着的方块是否被竖规格的方块填充(竖着的格子偶数)
// 将所有没有矛盾的 k 累加到一起就是 f[i,j] 的值
// 
// 答案:f[m,0](下标从 0 开始):前 m-1 列已经摆好, 从第 m-1 列伸到第 m 列的状态的为 0 (没有任何伸出来的所有方案) 即恰好是摆满 n*m 棋盘的所有方案
//                           将所有列的合法摆法加起来就是就是最终答案
//
// 每次枚举 i-1~i 列横着延伸的格子. 只要第 p 行有格子, 那么状态 j 的第 p 个状态就是 1
// 代表下一行状态的 k 和 j 相 & 为 0 就合法 (j & k == 0), 这代表不是同一行的
// 再满足所有空位置的长度必须是偶数, j | k 不能存在连续奇数个 0
//
// f[i,j] 表示的是当前要摆第 i 列, 方格状态是 j 的情况下
// 一共有 5 列
// j 为二机制数 (0~31)
// j : 上一列当中横向摆放的方格, 哪些列有这样的方格
//
// 状态压缩动态规划:
//      状态虽然是一个整数, 但是要将它看做二进制数, 二进制位中是 0 是 1 表示不同的情况
#include <iostream>
#include <cstring>

using namespace std;

const int N = 12, M = 1 << N;

long long f[N][M];
int st[M];

int main()
{
    int n, m;
    while (cin >> n >> m, n || m)
    {
        memset(f, 0, sizeof f);
        
        // 枚举 n^2 种状态
        for (int i = 0; i < 1 << n; ++ i)
        {
            st[i] = true;  
            int cnt = 0;                    
            for (int j = 0; j < n; ++ j)    // 枚举所有状态 i 的每一位, 看看是否存在连续奇数个 0
            {
                if (i >> j & 1)             // 不能存在连续奇数个 0, 因此每碰到一个 1 就统计一下前面的 0
                {
                    if (cnt & 1) 
                    {
                        st[i] = false;
                        break;
                    }
                }
                else cnt ++ ;
            }
            if (cnt & 1) st[i] = false;
        }
        
        // 第 0 列状态是 0 有 1 种合法方案
        // 横着放的话从 1 开始, 因为第 0 列不够两个格子
        f[0][0] = 1;
        // 枚举每一列
        for (int i = 1; i <= m; ++ i )
            for (int j = 0; j < 1 << n; ++ j )
                for (int k = 0; k < 1 << n; ++ k )
                    if ((j & k) == 0 && st[j | k])
                        f[i][j] += f[i - 1][k];         // 累加上上一列的状态
        
        printf("%lld\n", f[m][0]);
    }
    return 0; 
}
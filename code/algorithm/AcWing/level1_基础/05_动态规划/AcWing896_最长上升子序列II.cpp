// 最长上升子序列:贪心优化
// 例 : 3 1 2 1 8 5 6
// 因为 8 5 6 既然可以插在 3 后面, 那就一定也可以插在 1 后面
// 并且以 1 结尾的上升子序列更好(更小的可以插的值也更多)
// 所以可以使用贪心, 将以长度为单位记录以哪个数字结尾更小记录到数组中去 
// 猜测:随着长度的增加, 结尾的值一定是严格单调递增的, 长度越长, 结尾的值就一定越大
// 证明:假设一共 6 个数, 因为是按照结尾严格递增, 
//      如果长度是 6 的最长上升子序列结尾 < 长度是 5 的最长上升子序列结尾
//      那么长度为 5 的就可以插在长度为 6 后面, 长度就更长了, 长度不止 5, 这就矛盾了
// 
// 思路:每次找以当前长度结尾的最小值
// 有了这样一个思路后, 就可以在数组中求出最大的小于 a[i] 的数, 这里直接用二分
//
// 时间复杂度: O(n*logn)
// 
// 如果 1(较小的) 在 a[] 数组的最后呢 ?
// 我们求的是最长上升子序列, 太靠后就不需要了
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
int a[N];
int q[N];

// 2023.1.29 更新: 求上升子序列是针对每个结尾求让数尽可能的小
//                 但是要大于前面的数，那么 l 找的就是小于 x 的最大的数
int main()
{
    cin >> n;
    for (int i = 0; i < n; ++ i ) cin >> a[i];
    
    int len = 0;
    // 处理边界, 为了保证 q[] 上小于 a[i] 的某个数一定存在保证边界,
    // 将 q[0] 赋值为哨兵
    q[0] = -2e9;    

    // 枚举所有数
    for (int i = 0; i < n; ++ i ) 
    {
        int l = 0, r = len; 
        while (l < r)                           
        {
            int m = (l + r + 1) >> 1;
            // 如果 q[m] < a[i] 那么, 那么 a[i] 一定在 q[m] 的右边
            // 所以用左边来找, 每次都以缩减一半的速度靠近 a[i]
            // 所以二分到最后算出的就是小于 a[i] 的最大的(l的位置)
            // 所以在 q[l + 1] 的位置插入 a[i]
            if (q[m] < a[i]) l = m; 
            else r = m - 1;
        }
        len = max(len, l + 1);  // 更新最大值(r/l找的是可以接在哪个长度的后面的数)
        q[l + 1] = a[i];        // 接在后面后长度会+1, 所以用 +1 来更新
    }

    cout << len << endl;
    return 0;
}
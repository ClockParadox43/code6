// 数据范围
// 1 ≤ N ≤ 300
// 状态表示:所有将第 i 堆石子到第 j 堆石子合并成一堆石子的合并方式
//     集合:以最后一次的合并作为区间划分(最后一次分界线的位置, 从第 i 堆到第 j 堆的合并方式分成 k 类)
//          在这类集合中每一类的最小代价求 min
// 状态计算: 
//                  f[i,j]
//              ____________________________
//             |l:1  |l:2  |l:3  |... |l:k-1|
//             |_____|_____|_____|____|_____|
//             |r:k-1|r:k-2|r:k-3|    |r:1  |
//             |_____|_____|_____|____|_____|
//               min   min   min  min   min   -> 这类合并方式的最少代价  
//          以最后一次的合并作为区间划分
//          在这类集合中求Min
//
//          k=j-i+1 -> 当前合并的区间元素个数
// 
//          f[i,k] + f[k+1,j] -> 两堆石子合并的最小代价加到一起就是除了最后一步之外的最小代价
//          最后一步的代价就是从第 i 堆到第 j 堆石子的总重量
//          所有类都需要合并左右得到当前最小代价, 所以可以将最后一步去掉, 再加回省却的步骤
//          (所有同学减去相同分数并不影响最大值是谁)
//          f[i,k] + f[k+1,j] + s[j] - s[i-1](从第 i 堆到第 j 堆石子的总重量)
//
// 最外层循环长度, 里层循环左区间, 通过长度和左区间计算出右区间, 保证再计算的时候计算出子区间
// 时间复杂度:状态数量是 n^2 加状态计算枚举 k, O(n^3)
//            300^3 ≈ 2.7 * 10^7
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 310;

int n;
int s[N];
int f[N][N];

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; ++ i ) scanf("%d", &s[i]);

    // 前缀和数组
    for (int i = 1; i <= n; ++ i ) s[i] += s[i - 1];

    for (int len = 2; len <= n; ++ len )
        for (int i = 1; i + len - 1 <= n; ++ i )
        {
            int l = i, r = i + len - 1;         // l:起点, r:终点
            f[l][r] = 1e8;
            for (int k = l; k < r; ++ k )
                f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);  // 合并结果 + 合并总代价
        }

    printf("%d", f[1][n]);
    
    return 0;  
}
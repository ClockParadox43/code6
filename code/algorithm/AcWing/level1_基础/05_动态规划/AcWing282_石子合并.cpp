// 数据范围
// 1 ≤ N ≤ 300
// 状态表示:所有将第 i 堆石子到第 j 堆石子合并成一堆石子的合并方式
//     集合:以最后一次的合并作为区间划分(最后一次分界线的位置, 从第 i 堆到第 j 堆的合并方式分成 k 类)
//          在这类集合中每一类的最小代价求 min
// 状态计算: 
//                  f[i,j]
//              ____________________________
//             |l:1  |l:2  |l:3  |... |l:k-1|
//             |_____|_____|_____|____|_____|
//             |r:k-1|r:k-2|r:k-3|    |r:1  |
//             |_____|_____|_____|____|_____|
//               min   min   min  min   min   -> 这类合并方式的最少代价  
//          以最后一次的合并作为区间划分
//          在这类集合中求Min
//
//          k=j-i+1 -> 当前合并的区间元素个数
// 
//          f[i,k] + f[k+1,j] -> 两堆石子合并的最小代价加到一起就是除了最后一步之外的最小代价
//          最后一步的代价就是从第 i 堆到第 j 堆石子的总重量
//          所有类都需要合并左右得到当前最小代价, 所以可以将最后一步去掉, 再加回省却的步骤
//          (所有同学减去相同分数并不影响最大值是谁)
//          f[i,k] + f[k+1,j] + s[j] - s[i-1](从第 i 堆到第 j 堆石子的总重量)
//
// 最外层循环长度, 里层循环左区间, 通过长度和左区间计算出右区间, 保证再计算的时候计算出子区间
// 时间复杂度:状态数量是 n^2 加状态计算枚举 k, O(n^3)
//            300^3 ≈ 2.7 * 10^7
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 310;

int n;
int s[N];
int f[N][N];

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; ++ i ) scanf("%d", &s[i]);

    // 前缀和数组
    for (int i = 1; i <= n; ++ i ) s[i] += s[i - 1];

    for (int len = 2; len <= n; ++ len )        // 枚举长度
        for (int i = 1; i + len - 1 <= n; ++ i )    // 枚举每一组终点起点(为什么-1, 代入换算下即可, i+len-1是终点)
        {
            int l = i, r = i + len - 1;         // l:起点, r:终点
            f[l][r] = 1e8;
            // 在终点起点的范围内枚举分割线, 因为必须右边还有剩下所以 k < r
            for (int k = l; k < r; ++ k )
                f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);  // 合并结果 + 合并总代价
            
            // f[l][r] 表示的是将 l~r 这一段合并成一堆的方案的集合
            // 第三层循环每次不断更新 f[l][r], 在 l~r 这个区间内, 枚举分割线, 得到最优解
            // 因为 l~r 是在不超过 len 的基础上从小到大枚举, 所以之前合并在家的格子也能被找到
            // 忘了自己画图 
        }

    printf("%d", f[1][n]);
    
    return 0;  
}
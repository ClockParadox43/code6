
                   DP分析

01背包(每件物品只能使用一次):

   1) 状态表示 f(i,j) 集合中存的所有选法价值的最大值

                所有选法 
              / 
		- 集合 
              \     / 1) 只从前 i 个物品中选  
                条件                        -> 满足这两个条件的所有选法组成的集合
                    \ 2) 总体积 <= j        

		     f(i,j)的每一个状态其实表示的是一个集合
		     f(i,j)存的其实是一棵树 (选和不选的树, 最终表中每个状态下填下答案)
          


		- 属性: Max, Min, 数量 -> (一般来说属性只有 3 种)


   2) 状态计算 -> 集合的划分
                    - 不包含:
                          总体积从 1~i-1 当中选总体积不超过 j 
                          并且不包含 i 
                        
                    - 包含:
                          从 1~i 中选, 且总体积不超过 j, 且包含 i  



先思考 状态表示 再思考 状态计算 

    - 状态表示考虑两个方面的问题 

        1) 表示的是哪一个集合
            - 在 01 背包问题中表示的 所有选法 符合所有条件的一个集合

        2) 表示集合的树是代表的哪个属性




完全背包问题(每件物品用无限次):
   
   1) 状态表示 f(i,j)
        
        - 集合: 所有只考虑前 i 个物品, 且总体积不大于 j 的所有选法

        - 属性: Max Min 数量

                  所有选法中都包含第 i 个物品, 删除, 为第 i 个物品留合适的位置, 在加上第 i 个物品的价值 
                  

   2) 状态计算: 集合的划分
    
    f(i,j): 集合可以按照选多少个来划分(不能无限选择, 因为背包容量有限) 
             __________________
            | 0| 1| 2|..|k-1| k|   
            |__|__|__|__|___|__|   
                                   f[i-1,j]: 第 i 种物品不考虑
                                   f[i,j-v[i]*k] + w[i]*k: 考虑第 i 种物品

多重背包(每件物品只能使用有限次)

为什么多重背包问题需要用单调队列优化, 但是完全背包问题需要:
    - 多重背包求的是滑动窗口内的最大值
      完全背包问题求的是前缀的最大值 (从 1 开始的最大值, 然后多一个数(k)加上v[i], 再求最大值)
      每层在原有基础上继续更新
      可以用变量来存


分组背包问题(枚举每组第 i 件物品选哪个, 或者不选)
    
    1) 状态表示 f(i,j)

         - 集合: 只从前 i 组物品中选, 且总体积不大于 j 的所有选法
         
         - 属性: Max Min 数量
    

    2) 状态计算
            
     f(i,j):
             ______________________________________
            |i[j]|i+1[j]|i+2[j]|...|i+k-1[j]|i+k[j]|  
            |____|______|______|___|________|______|

                                                        f[i-1, j]: 第 i 组物品不选, j 其实是第 i 组物品中的第 k 个物品
                                                        f[i-1, j - v[i, k]] + w[i, k]: 从第 i 组物品中选第 k 个物品


如果用的是上层状态就是大到小枚举体积 -> 防止覆盖
如果本层状态就是小到大枚举体积
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstring>

using namespace std;
const int MAXN = 10005;

int n, m;
int a[MAXN];
bool st[MAXN];

// 对于第 i 根手指, 它有 n-i+1 种选择, 根据位值原理, 
// 要想让每个数对应一个全排列, 就要让这一位数是 n-i+1 进制的
// 
// 起始排列: 1 4 5 2 3
// 1 -> { 1, 2, 3, 4, 5 }, 1 有 5 种选择, 它的进制数就是 0
// 4 -> { 2, 3, 4, 5 }, 4 有 4 种选择, 它的进制数就是 2
// 5 -> { 2, 3, 5 }, 5 有 3 种选择, 它的进制数就是 2
// 2 -> { 2, 3 }, 2 有两种选则, 所以它的进制数为 0
// 3 -> { 3 } 3 有 3 种选则, 它的进制数是 0
// 当递归的时候, 前面的数字下一层的数字是不能选择的
// 
// 最后，排列 1, 4, 5, 2, 3 变成了(02200)
// 这本质其实就是模拟了一个递归序, 层数u(1, 2, 3... ), 越靠近上游那么可以做的选择也就越多, 所以进制也就越多
// 越靠近下游, 在当前层能枚举的数字也就越少, 拿最后一层举例子, 选择一个数字当前层就枚举完了, 下次选数的时候就是从上面递归下来了
// 这个操作可以看做是一个进位
// 
// 那么它需要进位几次(来到当前层几次), 就要看它的进制了
// 加的数永远不会超过第一层
int main()
{
    scanf("%d%d", &n, &m);

    // 将火星数变成进制数, 排在更前面的数选择也更多, 所以被减去的也更少
    // 火星数的进制数只和自己的选择有关
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        int x = a[i];
        for (int j = 1; j <= a[i]; j++)
            x -= st[j];     // 减去能选择的数
        st[a[i]] = 1;
        a[i] = x - 1;       // 因为从 0 开始所以需要减 1
    }

    // 进制数加上 m, 因为层数不一样, 所以自己的进制也不一样
    // 对于第 i 根手指, 它有 n-i+1 种选择, 根据位值原理
    // a[i-1]:倒数第 2 位, 倒数第 2 位是二进制
    // 0 += 3/1 = 3 加上
    a[n] += m;
    for (int i = n; i > 0; --i)
    {
        a[i - 1] += a[i] / (n - i + 1);  // 将 m 往前挪动, 以便于被每个数取到 
        a[i] %= n - i + 1;               // 当前位 % 上自己的进制得到加上 m 后的数
    }
    
    // 变回火星数, 从高位开始枚举, 将之前的步骤倒着来一遍
    // 之前减去的选项现在加回来
    memset(st, 0, sizeof st);
    for (int i = 1; i <= n; ++i)
    {
        for (int j = 0; j <= a[i]; ++j)
            if (st[j]) 
               a[i] ++;
        cout << a[i] + 1 << " ";        // 0 位置对应第一个选项, 因为从 0 开始所以加 1 
        st[a[i]] = 1;           // 0 位置标记为选过
    }
}

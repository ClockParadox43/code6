// 同样的复杂度通常能获得更多的信息, 在该问题中, 我们不光能求出能否得到目标的和数
// 同时把得到时 ai 这个数还剩下多少个计算出来, 这样就能减少时间复杂度
//
// dp[i+1][j]:用前 i 种数字加和得到 j 时第 i 种数最多能剩余多少个(不能加和得到 j 的情况下为 -1)
//     - 这样想, 如果前 i-1 个数字的累加和得到 j 的话, 那么第 i 种数字就还能剩下 m 个
//       如果前 i 个数累加和得到 j-a[i] 的话, 那么该种数字还能剩下 k 个, 用这 i 种数字加到 j 时, 第 i 种数字就能剩下 j-1 个
// 

#include <iostream>
#include <cstring>
using namespace std;
const int MAXN = 105, MAXK = 100010;

int n = 3, K = 17;
int a[3] = {3, 5, 8};
int m[3] = {3, 2, 2};
int dp[MAXK];

int main()
{
    memset(dp, -1, sizeof dp);
    dp[0] = 0;
    for (int i = 0; i < n; ++ i)
        for (int j = 0; j <= K; ++ j)
        {
            // 之前剩余的张数被更新过的情况, 开始选第 i+1 个数字了
            // i 也表示第 i 个数字, 同时也说摸 i 这个数字是可以到达的, 这样 dp[j - a[i]] 
            // 时就可以到达 i, 然后此时的 dp[j] 一定已经被更新成 a[i] 所剩余的张数
            // 既然, 我们能到达过 i 这个数字, 当前的 a[i] + i(下标表示来到过该数字) 又能组成 j
            // 所以 dp[j - a[i]] - 1, a[i] 的张数用掉一张
            // dp[j]作用:标记当前的第 a[i] 个纸币张数是用过的, 并且更新为 a[i+1] 的纸币的张数
            // 判断 a[i] 这张纸币 是否可以和 a[i + 1] 纸币配合求出
            if (dp[j] >= 0)
                dp[j] = m[i];
            else if (j < a[i] || dp[j - a[i]] <= 0)
            {
                // 如果要组成的数字 j < a[i] 的数字, 说明组成不了
                // dp[j - a[i]] <= 0 说明当前 j 选择减去 a[i] 这个数, 但是剩下的张数 <= 0
                dp[j] = -1;
            }
            else    
            {
                // j 能够减满 a[i], a[i] 就会少一张
                // j - a[i] 找到之前减去 a[i] 还剩下多少张的情况, 在此基础上减去一个 1
                dp[j] = dp[j - a[i]] - 1;
            }
        }
    
    // 最终如果能推到 K 就说明组成过该数字, 
    if (dp[K] >= 0) puts("Yes");
    else puts("No");

    return 0;
}